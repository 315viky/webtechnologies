Routing and Navigation
----------------------
https://blog.angularindepth.com/the-three-pillars-of-angular-routing-angular-router-series-introduction-fb34e4e8758e


- The Angular Router enables navigation from one view to the next as users perform application tasks

Overview
---------

- The browser is a familiar model of application navigation
- Enter a URL in the address bar and the browser navigates to a corresponding page
- Click links on the page and the browser navigates to a new page.
- click the browsers back and forward buttons and the browser navigates backward and forward 
  through the history of pages you have seen.


- The Angular Router ("the router") borrows from this model.
- It can interpret a browser URL as an instruction to navigate to a 'client-generated' view.
- It can pass optional parameters along to the supporting view component that help it decide what specific 
  content to present.
- You can bind the router to links on a page and it will navigate to the appropriate application view
  when the user clicks a button, selects from a drop box or in response to some other stimulus from any source
- The router logs activity in the browser's history journal so the back and forward buttons work as well


The Basics
__________

- This guide proceeds in phases, marked by milestones, starting from a simple two pager and building
  towards a modular, multi-view design with child routes

- An introduction to a few core router concepts will help orient you to the details that follow

<base href>
- Most routing application should add a <base> element to the index.html as the first child in the 
  <head> tag to tell the router how to compose navigation URLs
- If the app folder is the application root, as it is for the sample application, set the href value
  exactly as shown here

src/index.html(base-href)
 <base href="/">

Router Imports
-----------
- The Angular Router is an optional service that presents a particular component view for a given URL.
- It is not part of the Angular core.
- It is in its own library package, @anguar/router.
- Import what you need from it as you would from any other Angular app

src/app/app.module.ts(imports)

import { RouterModule, Routes } from '@angular/router';

Configuaration
--------------
- A routed angular application has one singleton instance of the Router service.
- When the browser's URL changes, the router looks for a corresponding Route from which it can determine 
  the component to display.

- A Router has not routes until you configure it.
- The following example creates five route definitions, configures the router via the RouterModule.forRoot()
  method and adds the result to the AppModule's import array

src/app/app.module.ts
---------------------

const appRoutes: Routes = [
    { path: 'crisis-center', component: CrisisListComponent },
    { path: 'hero/:id',      component: HeroDetailComponent },
   
    { path: 'heroes',
      component: 'HeroListComponent',
      data: { title: 'Heroes List' }
    },
    
    { path: '',
      redirectTo: '/heroes',
      pathMatch: 'full'
    },

    { path: '**', component: PageNotFoundComponent }
];      
 

@NgModule({
   imports: [
      RouterModule.forRoot(
         appRoutes,
         { enableTracing: true } // <--debugging purposes only
      ),

      // Other imports follow
  
    ...
  ]
 });

export class appModule { };


- The appRoutes array of routes describes how to navigate.
- Pass it to the RouterModule.forRoot() method in the module imports to configure the router

- Each Route maps a URL path to a component. There are no leading slashes in the path
- The router parses and builds the final URL for you, allowing you to use both relative and absloute
  paths, when navigating between application views

- The :id in the second route is a token for a route parameter.
- In a URL such as /hero/42, "42" is the value of the id parameter. The corresponding HeroDetailComponent
  will use that value to find and present the hero whose id is 42. ( route parameters)
- The data property in the third route is a place to store arbitrary data associated with this specific route
  The data property is accessible within each activated route. Use it to store items such as page titles,
  breadcrumb text and other read only static data.
- Use the 'resolve guard' ( later looked into) to retrive dynamic data
- The empty path in the fourth route represents the default path for the application and place to go when
  the URL is empty as it typically is at the start.

- The ** path in the last route is a wildcard. 
- The router will select this route if the request URL doesnt match any paths for routes defined earlier in
  the configuration
- This is useful for displaying a '404 - not found ' page or redirecting to another route

- The order of the routes in the configuration matters and this is by design.
- The router uses a first match wins strategy when matching routes, so more specific routes should be placed
   above less specific routes.
- In the configuration above, routes with a static path are listed first, followed by an empty path route,
  that matches the default route.
- The wild card route comes last because it matches every URL and should be selected only if no other routes are
  matched first

- If you need to see what events are happening during the navigation lifecycle, there is the enableTracing
  option as part of the router's default configuration.
- This outputs each router event that took place during each navigation lifecycle to the browser console.
- This should only be used for debugging purposes.

Router outlet
_____________

- The RouterOutlet is a directive from the router library that is used like a component.
- It acts as a placeholder that marks the spot in the template where the router should display the components
  for that outlet.

  <router-outlet></router-outlet>
  <!--Routed components go here -->
  
- Given the configuration above, when the browser URL for this application becomes /heroes, the router
  matches that URL to the route path /heroes and displays the HeroListComponent as a sibling element
  to the RouterOutlet that you've placed in the host component's template

Router links
____________
- Now you have routes configured and a place to render them, but how do you navigate ?
- The URL could arrive directly from the browser's address bar.
- But most of the time you navigate as a result of some user actions such as a click on an anchor tag

src/app/app.component.html
--------------------------
<h1>Angular Router</h1>
<nav>
  <a routerLink="/crisis-center"   routerLinkActive="active">Crisis Center</a>
  <a routerLink="/heroes"   routerLinkActive="active">Heroes</a>
</nav>
<router-outlet></router-outlet>

- The RouterLink directives on the anchor tags give the router control over those elements
- The navigation paths are fixed, so you can assign a string to the routerLink(a "one-time" binding)
- Had the navigation path been more dynamic, you could have bound to a template expression that returned
  an array of route link parameters(the link parameters array). The router resolves that array into a
  complete URL

Active router links
___________________
- The RouterLinkActive directive toggles css classes for active RouterLink bindings bases on the current
   RouterState
- On each anchor tag, you see a property binding to the RouterLinkActive directive that look like 
  routerLinkActive="..."

- The template expression to the right of the equals(=) contains a space delimited string of CSS classes
   that the Router will add when this link is active(and remove when the link is inactive).
- You set the RouterLinkActive directive to a string of class such as [routerLinkActive]="'active fluffy'" or
  bind it to a component property that returns such a string


- Active Route links cascade down through each level of the route tree, so parent and child router links
  can be active at the same time
- To override this behaviour, you can bind to the [routerLinkActiveOptions] input binding with the
  {exact: true} expression.
- By using {exact: true}, a given RouterLink will only be active if its URL is an exact match to the current
  URL

Router State
____________

- After the end of each successful navigation lifecycle, the router builds a tree of ActivatedRoute objects
  that make up the current state of the router.
- You can access the current RouterState from anywhere in the application using the Router service and 
  routerState property

- Each activatedRoute in the RouterState provides methods to traverse up and down the route tree to
  get information from parent, child and sibling routes

Activated route
________________
The route path and parameters are available through an injected router service called the ActivatedRoute.
It has a great deal of useful information including:

url - An Observable of the route path(s), represented as an array of strings for each part of the route path
data - An observable that contains the data object provided for the route.Also contains any resloved values
       from the resolve guard
paramMap - An Observable that contains a map of the required and optional paramters specific to the route.
           The map supports retrieving single and multiple values from the same parameter

interface ParamMap {
  keys: string[]
  has(name: string): boolean
  get(name: string): string | null
  getAll(name: string): string[]
}

queryParamMap - An Observable that contains a map of the query parameters available to all routess.
                The map supports retrieving single and multiple values from the query parameter

fragment - AN Observable of the URL fragemnt available to all routes

outlet - The name of the RouterOutlet used to render the route. FOr an unnamed outlet, the outlet name is primary

routeConfig - The route configuration used for the route that contains the origin path

parent - The route's parent ActivatedRoute when this route is a child route

firstChild - COntains the first ActivatedRoute in the list of this route's child routes

children - contains all the child routes activated under the current route

Two older properties are still available. They are less capable than their replacements, discouraged, and may be deprecated in a future Angular version.

params—An Observable that contains the required and optional parameters specific to the route. Use paramMap instead.

queryParams—An Observable that contains the query parameters available to all routes. Use queryParamMap instead.







Router events
_____________
- During each navigation, the Router emits navigation events through the Router.events property
- These events range from when the navigation starts and ends to many points in between.

List of Navigation events

NavigationStart - An event triggered when navigation starts
RouteConfigLoadStart - An event triggered before the Router lazy loads a route configuration
ROuteCOnfigLoadEnd - AN event triggrt after a route has be lazy loaded
RoutesRecognized - An event triggered whem teh Router parses the URL and routes are recognized
GuardsCheckStart - An event triggered when the Router begins the Guards phase of routing
ChildActivationStart - An event triggered when the Router begins activating a route'c children
ActivationStart - when the Router begins activating a route
GuardsCHeckEnd - Router finishes Guards phase of routing successfully
ResolveStart - when router begins Resolve phase ofrouting
ResolveEnd - An event triggered when the Router finishes resolve phase of routing successfully
ChildActivationEnd - finishes activating child route
ActivationEnd - finishes activating a route
NavigationEnd - Nagivation cycle ends
NavigationCancel - An event triggered when navigation is cancelled. This is due to a Route Guard returning
                   false during navigation
NavigationError - When Navigation fails due to an unexpected error
Scroll - AN event that represents a scrolling event

- These events are logged to the console when the enableTracing option is enabled also.
Summary
_______
- The application has a configured router.
- The shell component has a RouterOutlet where it can display views produced by the router.
- It has RouterLinks that users can click to navigate via the router.

Here are the key Router terms and their meanings

Router Part                       Meaning


Router -      Displays the application component for the active URL. Manages navigation from one component
              to  the next
RouterModule- A seperate NgModule that provides the necessary service providers and directives for 
              navigating through application views
Routes - Defines an array of Routes, each mapping a URL path to a component
Route - Defines how the router should navigate to a compoenent based on a URL pattern. Most routes consist of 
        a path and a component type.

RouterOutlet - The directive(<router-outlet>) that marks where the router displays a view

RouterLink - The directive for binding a clickable HTML element to a route. Clicking an element with a 
              routerLink directive that is bound to a string or a link parameters array triggeres a navigation

RouterLinkActive - The directive for adding/removing classes from an HTML element when an associated routerLink
                   contained on or inside the element becomes active/inactive

ActivatedRoute - A service that is provided to each route component that contains route specific information
                 such a route paramters, static data, resolve data, global query params and global fragment

RouterState - The current state of the router including a tree of the currently activated routes together
              with convenience methods for traversing the route tree



Link Paramters array - An array that the router interprets as a routing instruction. You can bind that array to
                       a RouterLink or pass the array as an arguement to the Router.navigate method

Routing Component - An angular component with a RouterOutlet that displays views based on router navigations





Some practical exercise...



The Sample application
_______________________

- ng new simple-angular-router
- ng generate component crisis-center
- ng generate component heroes-list

Mile stone 1 - two navigation tabs with crisis center and heroes

1 Register the Router
- register the RouterModule from the @angular/router package
- Define an array of routes, appRoutes and pass them to the router, RouterModule.forRoot() method
- It returs RouterModule service and other services required for the routing library
- Once the application is bootstrapped, the Router performs initial navigation based on the browsers current url		 

2 Add the router-outlet

- The root AppComponent is the application shell. It has a title, a navigation bar with two links and 
  a router outlet where the router swaps componenets on and off the page
- The router outlet serves as a placeholder when the routed components will be rendered below it

3 Add a wild card Route ( if there is no matching route )
  routes = [
   path = '**', any existing component or page not foud component

4 Set up redirects
- When the application launches, the inital URL in the browsing bar is something like this
  localhost:4200
- This will not match any url and will hit the wild card to display page not found
- The application needs a dafualt root to a valid page	. Default page for this app is the list of heroes
- Preferred solution is to add a redirect route that translates the initial relataive URL('')
  to the desired path (/heroes) 
- The browser address bar shows .../heroes as if you'd navigated there directly

- pathmatch: 'full' or 'prefix'
  full - route only if the whole url matches the path
  prefix - route if anything is prefixed with the path


5 Basics WrapUp
- Loading the router library
- Adding nav bar to the shell template with anchor tags, routerLink and routerLinkActive directives
- Add a router-outlet to the shell template where views will be displayed
- Configure the router module with RouterModule.forRoot().
- Set the router to compose HTML5 browser URL's
- Handle invalid routes with a wildcard route
- navigate to the default route when the app launches with an empy path


Milestone 2: Routing Module

- In the initial route configuration, you provided a simple setup with two routes used to configure the application
  for routing
- As the application grows and you amke use of more Router features such as guards, resolvers and child routing
  you ill want to refactor the routing configuration into its own file.
- Move the routing information into a special-purpose module called a Routing Module 

The Routing Module has several characteristics:
 - Saperates routing concerns from other application concerns
 - Provides a module to replace or remove when testing the application
 - Provides a well-known location for routing service providers including guards and resolvers
 - Does not declare components

- Choosing to have a saperte Routing module is a design choice - depends on the complexity of the routing
  involved
- For simpler Routing usecases, configurations can be kept in the feature module

Milestone 3: Heroes feature
____________________________

- You have seen how to navigate using the RouterLink directive. 
- Now you ill learn
   Organize the app and routes into feature areas using modules
   Navigate imperatively from one component to another
   Pass required and optional information in route paramters


- Selectors are not required for routed components due to the components are dynamically 
inserted when the page is rendered, but are useful for identifying and targeting them
in your HTML element tree


- WHen the routes are distributed accross modules, then the order of import
  of these modules will be the order of routing used by the router

Route Parameters
________________

Route definitions with a parameter
----------------------------------
{ path: 'hero/:id', component: HeroDetailComponent }

- Notice the :id token in the path. This creates a slot in the path for a 
  Route Paramter.
- In this case, the router will insert the id of a hero onto that slot

Setting the route paramters in the list view
-------------------------------------------
<a [routerLink]="['/hero', hero.id]">

- After navigating to HeroDetailComponent, you expect to see the details of the selected hero.
- You need two pieces of information : the routing path to the component and the hero id

- Accordingly the link parameters array has two items - routing path and router paramter that specifies 
  the id of the selected hero

How does the target HeroDetailComponent learn about that id? Don't analyze the URL. Let the router do it.
The router extracts the route parameter (id:15) from the URL and supplies it to the HeroDetailComponent via the ActivatedRoute service.

Activated Route in action
-------------------------
- Import the Router, ActivatedRoute and ParamMap tokens from the route package
- Provide these service to herodetail component in the constructor
- Later on ngOnInit method, you use the ActivatedRoute service to retrieve the parameters for the 
  route , pull the hero ID from the paramters and retrieve the hero to display

  noOnInit() {
    this.hero$ = this.route.paramMap.pipe(
       switchMap((params: ParamMap) =>
         this.service.getHero(params.get('id')))
      );
   }

- The paramMap processing is a bit tricky. When the map changes, you get() the id parameter from the 
  changed paramters
- Then you tell the HeroSerive to fetch the hero with that id and return the result of the HeroService request
- You might think to use the RxJs map operator. But the HeroService returns an Observable<Hero>.
  so you flatten the Observable with the switchMap operator instead
  - SwitchMap operator also cancels previous in-flight requests. If the user re-navigates to this route
    with a new id while the HeroService is still retrieving the old id, SwitchMap discards the old request and
    returns the hero for the new id.

- The observable subscription will be handled by the AsyncPipe and the components hero property will be
   reset with the retrieved hero


ParamMap API
-------------
has(name)
get(name)
getAll(name)
keys

Observable ParamMap and Component Reuse
---------------------------------------
- ParamMap provides a way to reuse the component instance if you need to navigate to same component with
different parameter.
- This avoids destroying the component from DOM and recreating the same instance with different ID
- It detects when the routerParameter changes form within the same instance


No need to unsubscribe for the ActivateRoute observables as will be destroyed with the router component when the
router no longer needs it


snapshot: the no-observable alternative
---------------------------------------
- If we are sure of not reusing the same component - like navigating by switching only the route param,
  then we dont need to observe for paramter change with paramMap

- this is non observable paramMap usage, with snapshot

- the route.snapshot provides the initial value of the route paramter map
- you can access the paramters directly without subscribing or adding observable operators

ngOnInit() {
  let id = this.route.snapshot.paramMap.get('id');
   this.hero$ = this.serivice.getHero(id);
}

Remember: you only get the initial value of the parameter map with this technique. 
Stick with the observable paramMap approach if there's even a chance that the router could 
re-use the component. 
This sample stays with the observable paramMap strategy just in case


Navigating back to the list component
--------------------------------------
- The HeroDetailComponent has a "Back" button wired to its gotoHeroes method that navigates 
  impertatively back to the HeroListComponent

- The router 'navigate' method takes the same one-item link paramters array that you can bind to
  a [routerLink] directive. It holds the path to the HeroListComponent

gotoHeroes() {
  this.router.navigate(['/heroes']);
}

Route Paramters: Required or optional?
--------------------------------------
- Use route parameters to specify a required paramter value within the route
  URL as you do when navigating to the HeroDetailComponent in order to view
  the hero with id 15
  localhost:4200/hero/15

- You can aslo add optional information to a route request
- Example when returning to hero-list component from the hero detail view
  it would be nice if viewed hero was preselected in the list
- This can be implemented by including the viewed hero's id in the url as
  an optional parameter when returning from the HeroDetailComponent


ex: this.router.navigate(['/heroes', { id: heroId, foo: 'foo'}]);

- Now when you click a back button on the heroes detail view component
    url looks like this
localhost:4200/heroes;id=15;foo=foo

- The optional route paramters are not separted by "?" and "&" as they would
   be in an URL query string. They are separted by semicolons ";"
   This is matrix URL notation - something you may not have seen before

localhost:4200/heroes;id=id;foo=foo

Route paramters in the ActivatedRoute Service
----------------------------------------------
- Use the same paramMap property of the router to capture the route params
  when navigating to the herolist view. 
- In this case the route params will be optional { id: heroId, foo: 'foo' }


- subscribe to the router paramter map observable and make it available 
  to heroes list compoenent in the ActivatedRoute service

ngOnInit() {
   this.heroes$ = this.route.paramMap.pipe(
         switchMap(params => {
            this.selectedId = +params.get('id');
             return this.getHeroes();
          })
       );
  }

Adding routable animations
__________________________

Adding animations to the routed component
-----------------------------------------
Refer to the guide



Milestone 4: Crisis center feature
___________________________________

A crisis center with child routes
----------------------------------
Recommended pattern for Angular applications
 
- Each feature area resides in its own folder
- Each feature has its own Angular feature module
- Each area has its own root component
- Each area root component has its own router outlet and child roots
- Feature area routes rarely(if ever) cross with routes of other features

- The CrisesCenterComponent has the following in common with the AppComponent
  - It is the root of the crisis center area, just as AppComponent is the root
    of the entire application
  - It is a shell for the crisis management feature area, just as the AppComponent
    manage the high-level workflow

Like most shells, the CrisisCenterComponent class is very simple
- it has no business logic and its template has no links 
- just a title and <router-outlet> for CrisisCenter child components

- Notice that the parent crisis-center has a children property with a single route 
  containing the CrisisListComponent.
- The CrisisListComponent route also has a children array with two routes
   Th CrisisCenterHome component and CrisisDetailComponent

- There are important differences in the way router treats these child routes

- The router displays the components of these routes in the RouterOutlet of the 
  CrisisCenterComponent, not in the router outlet of AppComponent shell

- The CrisisListComponent contains the crisis list and a RouterOutlet to display the
  CrisisCenterHome and Crisis Detail route components

- The Crisis Detail route is a child of the Crisis List.
- The router reuses components by default, so the Crisis Details component will be 
   reused as you select differnet crisis.
   In contrast, back inthe hero detail route, the component was recreated each time
   you selected a different hero from the list of heroes
   
- How the url path works for child routes

-At the top level, paths that begin with / refer to the root of the application.
- But child routes extend the path of the parent route.
- With each step down the route tree, you add a slash followed by the route path
  unless the  path is empty

Apply that logic to navigation within the crisis center for which the parent path is
/crisis-center

- To navigate to the CrisisCenterHome component, the full URL is 
  /crisis-center (/crisis-center + '' + '')

- To navigate to the CrisisDetailComponent for a crisi with id=2, the full url is
  /crisis-center/2  (/crisis-center + '' + '/2')


The absolute URL for the latter example including the localhost origin is
localhost:4200/crisis-center/2

Relative Navigation
_____________________

- Instead of giving absoule path for navigation fromt the current path, we can use
  relative navigation

/crisis-center/2 => ../3

- To navigate a relative path with the Router.navigate method, you must supply the
  ActivatedRoute to give the router knowledge of where you are in the current route
  tree

- After the link paramters array, add an object with a relativeTo property set to the
  ActivatedRoute

Always specify the complete absolute path when calling router's navigateByUrl method.

Navigate to crisis list with a relative URL
__________________________________________

- You have already injected the ActivatedRoute that you need to compose the relative 
  navigation path

- When using a RouterLink to navigate instead of the router service, youd use the same
  link parameters array, but you wouldnt provide the object with the relativeTo property
- The ActiviatedRoute is implicit in RouterLink directive



Displaying multiple routes in named outlets
___________________________________________

- You decide to give users a way to contact crisis center. WHen a user clicks a "contact"
  button, you want to display a message in a popup view.
- The popup should stay open, even, when switiching between pages inthe application
  until the user closes it by sending the message or cancelling.

- Clearly you cantput the popup in the same outlet as the other pages.

- Until now, youve defined a single outlet and you've nested child routes under that
  outlet to group routes together. 
- The router only supports one primary unnamed outlet per template.

- A template can also have any number of named outlets.
- Each named outlet has its own set of routes with their own components
- Multiple outlets can be displaying diferent content , determined by different routes
  all at the same time


Add an outlet named "popup" in the AppComponent, directly below the unnamed outlet

Secondary routes
_________________

- Named outlets are the targets of secondary routes
- Secondary routes look like primary routes and you configure them in the same way.
  They differ in few key respects
 
  - They are independent of each other
  - They work in combination  with other routes
  - They are displayed in named outlets

Add a secondary route
----------------------
{
  path: 'compose',
  component: ComposeMessageComponent,
  outlet: 'popup'
},

<a [routerLink]="[{ outlets: { popup: ['compose'] } }]">Contact</a>

Secondary route navigation: merging routes during navigation
------------------------------------------------------------
- Navigate to the Crisis Center nd click "Contact", you should se something like the following  URL in the 
  browser address bar

  http://.../crisis-center(popup:compose)


The interesting part of the Url follows the..
  - The crisis-center is the primary navigation
  - Parentheses surround the secondary route
  - The secondary route consists of an outlet name (popup), a colon separator and the secondary route path
    (compose)

Click the Heroes link and look ar the URL again

http://.../heroes(popup:compose)

- The primary navigation part has changed, the secondary route is the same
- The router is keeping track of two seperate branches in a navigation tree and generating a representation
   of that tree inthe URL
- You can add many more outlets and routes, at the top level and in nested levels, creating a navigation 
  tree with many branches. The router will generate the URL to go with it

You can tell the router to navigate an entire tree at once by filling out the outlets object mentioned above. 
Then pass that object inside a link parameters array to the router.navigate method.

Clearing secondary Routes
________________________

By navigation to the router outlet 'popup ' with component as null

closePopup() {
  // Providing a `null` value to the named outlet
  // clears the contents of the named outlet
  this.router.navigate([{ outlets: { popup: null }}]);
}

Milestone 5: Route guards
_________________________

At the moment, any user navigate anywhere in the application anytime. That's not always the right thing to do
- Perhaps the user is not authorized to navigate to the target component
- Maybe the user must login(authenticate) first.
- Maybe you should fetch some data before you display the target component
- You might want to save pending changes before leaving a component
- You might ask the user if its OK to discard the changes rather than save them

You add guards to the route configuration to handle these changes

A guard's return value controls the router's behaviour:
 - If it returns true, the navigation process continues
 - If it returns false, the navigation process stop and the user stays put
 - If it returns a UrlTree, the current navigation cancels and a new navigation is initiated to the 
   UrlTree returned

Note: The guard can also thell the router to navigate elswhere, effectively ccancelling the current navigation.
       When doing so inside a guard, the guard should return false

- The guard might return its boolean answer synchronously.
- But in many cases, the guard cant produce an answer synchronously.
- The guard could ask the user a question, save changes to the server or fetch fresh data.
- These are all aynchronous operations

- Accordingly a routing guard can return an Observable<boolean> or a Promise<boolean> and the router will wait
  for the observable to resolve to true or false


Note - The Observable provided to the Router must also complete. If the observable does not complete, the
       navigation will not continue  


The router supports multiple guard interfaces:
   - CanActivate to mediate navigation to a route
   - CanActivateChild to mediate navigation to a child route
   - CanDeactivate to mediate navigation away from the current route
   - Resolve to perform route data retrieval before route activation
   - CanLoad to mediate navigation to a feature module loaded asynchronously

- You can have multiple guards at every level of a routing herarchy
- The router checks the CanDeactivate and CanActivateChild guards first, from the deepest child route to the
   top
- Then it checks the CanActivate guards from the top down to the deepest child route,
- If the feature module is loaded asynchronously, the CanLoad guard is checked before the module is loaded.
- If any guard returns false,  pending guards that have not completed will be cancelled and the entire navigation
  is cancelled.

There are several examples over the next few sections


CanActivate: requiring authentication
--------------------------------------
- Applications often retrict access to a feature area based on who the user is .
- You can permit access only to authenticated users or to users with a specific role. You might
  block or limit access intill the user's account is activated

The CanActivate guard is the tool to manage these navigation business rules

Add an admin feature module
-----------------------------
<h3>ADMIN</h3>
<nav>
  <a routerLink="./" routerLinkActive="active"
    [routerLinkActiveOptions]="{ exact: true }">Dashboard</a>
  <a routerLink="./crises" routerLinkActive="active">Manage Crises</a>
  <a routerLink="./heroes" routerLinkActive="active">Manage Heroes</a>
</nav>
<router-outlet></router-outlet>

Although the admin dashboard RouterLink only contains a relative slash without an additional URL segment,
it is considered a match to any route within the admin feature area

You only want the Dashboard link to be active when the use visits that route. 
- Adding an additional binding to the dashboard routerLink, [routerLinkActiveOptions]="{exact:true}",
  marks the ./link as active when the user navigates to the /admin URL and  no when navigating to child routes


Guard the admin feature
----------------------

- Currently every route within the Crisis Center is open to everyone.

- The new admin feature should be accessible only to authenticated users

- You could hide the link until the user logs in. But that's tricky and difficult to maintain

- Instead you ill write a canActivate() guard method to redirect anonymous users to the login page when
  they try to enter the admin area

- This is a general purpose guard - you can imagine  other features that require authenticated users - so you
  generate an AuthGuard in the auth folder

Teach AuthGuard to authenticate
-------------------------------

- Make the AuthGuard atleast pretend to authenticate
- The AuthGuard should call an application service that can login a user and retain information about
  the current user.



Add the login component
------------------------

- You need a LoginComponent for the user to login to the app .
- After logging in , you will redirect to the stored url if available or use the default URL 


CanActivateChild - Guarding child routes
________________________________________

- this is similar to CanActivate guard, difference is that this is called before any child routes
  are activated


CanDeactive - Handling unsaved changes
______________________________________

- In the "Heroes" workflow, the app accepts every change to a hero immediately without hesitation or
  validation.
- In the real world you might have to accumulate the users changes
- You might have to validate on the server.
- You might have to hold changes in a pending state until the user comfirms them as a group or cancels and
  reverts all changes

- what do you do about unapproved, unsaved changes when the user navigates away? You cant just leave and
  risk losing the user's changes, that would be a terrible experience
- Its better to pause and let the user decide what to do.If the user cancels, you ill stay put and allow
  more changes. If the user approves, the app can save
- You still might delay navigation untill the save succeeds. If you let the user move to next screen immediately
  and the save were to fail( perhaps data are ruled invalid), you would lose the context of the error
- You cant block while waiting for the server - thats not possiblw in a browser. You need to stop navigation
  while you wait, asynchronously, for the serve to return with its answer

- You need the CanDeactivate guard

Cancel and save
----------------
cancel() {
  this.gotoCrises();
}

save() {
  this.crisis.name = this.editName;
  this.gotoCrises();
}

Resolve: pre-fetching component data
____________________________________

- App is waiting until the route was activated to fetch the respective data.
- Its preferable to pre-fetch data from the server so it's ready the moment the route is activated
- You want to delay rendering the router component until all necessary data have been fetched

Fetch Data Before Navigating
----------------------------
- At the moment, the CrisisDetailComponent retrieves the selected crisis. If the crisis is not found, 
  it navigates back to the crisis list view.

- The experience might be better if all of this were handled first, before the route is activated.
- A CrisisDetailResolver service could retrieve a Crisis or navigate away if the Crisis does not exist 

ng generate service crisis-center/crisis-detail-resolver

- Take the relevent parts of the crisis retrieval logic in CrisisDetailComponent.ngOnInit and
  move them into the CrisisDetailResolverService.
- Import the Crisis model, CrisisService and the Router so you can navigate elsewhere if you can't fetch the
  crisis

Be explicit. Implement the Resolve interface with a type of Crisis

- Inject the CrisisService and Router and implement the resolve() method. That method could return a
  Promise, an Observable, or a synchronous return value
- The CrisisService.getCrisis method returns an observable, inorder to prevent the route from loading until
  the data is fetched.
- The Router guards require an observable to complete, meaning it has emitted all of its values.
- Use the 'take' operator with an arguement of 1 to ensure that the Observable completes after retrieving
  the first value from the Observable returned by the getCrisis method

- If it doesnt return a valid Crisis, return an empty Observable, cancelling the previous in-flight
  navigation to the CrisisDetailComponent and navigate the user back to the CrisisListComponent.

Two Critical Points
  - The router's Resolve interface is optional.The CrisisDetailResolverService doesnt inherit from a 
    base class. The router looks for that method and calls it if found
  - Rely on the router to call the resolver. Dont worry about all the ways that the user could navigate
    away. That's the router's job.

 
Query parameters and fragments
______________________________
- In the route parameters example, you only dealt with paramters specific to the route, but what if you wanted
  optional parameters available to all routes.
- This is where query parameters come into play

- Fragments refer to certain elements on the page identified with an id attribute.

Update the AuthGuard to provide a session_id query that will remain after navigating to another route
Add an anchor element so you can jump to certain point on the page
Add the Navigation extra objects to the router.navigate() method that navigates you  to the /login

let navigationExtras: NavigationExtras = {
      queryParams: { 'session_id': sessionId },
      fragment: 'anchor'
    };


- You can also preserve query paramters and fragments across navigations without having to provide them
  again when navigating. 
- In the LoginComponent, you ill add an object as the second arguement in the router.navigateUrl() function
  and provide the queryParamsHandling and preserveFragment to pass along the current query parameters
  and fragment to next route


Milestone 6: Asynchronous routing
_________________________________

- As the application size grows, it really takes a long time to load.
- With asynchronous routing, which loads feature modules lazily, on request
   - You can load feature areas only when requested by the user
   - You can speed up load time for users that only visit certain areas of the application
   - You can continue expanding lazy loaded feature areas with out increasing the size of the initial load
     bundle

- By organizing the application into modules - AppModule, HeroesModule, AdminModule and CrisisCenterModule
   - you have natural candidates for lazy loading.

- Some modules like AppModule, must be loaded from the start. But others can and should be lazy loaded.
- The AdminModule for example, is needed by a few authorized users - so you can only load it when requested by
   the right people

Lazy Loading route configuration
--------------------------------

- Change the admin path in the admin-routing.module.ts from 'admin' to an empty string, '', the empty path.
- The Router supports empty path routes, use them to group routes together without adding any additional
  path segments to the URL.
- Users will still visit /admin and the AdminComponent still serves as the Routing COmponent containing
  child routes

- Open the AppRoutingModule and add a new admin route to its appRoutes array.

- Give it a loadChildren property instead of a children property. The loadChildren property takes a
  function that returns a promise using the browser's built-in syntax for lazy loading code using dynamic
  imports import(...).
- The path is the loacation of the AdminModule( relative to the app root)
- After the code is requested and loaded, the Promise resolves an object that contains the NgModule, in this
  case the AdminModule

- When the router navigates to this route, it uses the loadChildren string to dynamically load the 
  AdminModule.
- Then it adds the AdminModule routes to its current route configuration .
- Finally it loads the request route to the destination admin component


- The lazy loading and re-configuration happen just once, when the route is first requested; the module routes
  are available immediately fro subsequent requests

"Angular provides a built-in module loader that supports SystemJS to load modules asynchronously.
 If you were using another bundling tool, such as Webpack, you would use the Webpack mechanism for
 asynchronously loading modules"

- Take the final step and detach the admin feature set from the main application.
- The root AppModule must neither load nor reference the AdminModule or its files.

- In the app.module.ts remove the AdminModule import statement from the top of the file and remove the
  AdminModule from the NgModule's import array


canLoad Guard - guarding the unauthorized loading of feature modules
____________________________________________________________________

- You are already protecting the AdminModule with a CanActivate guard that prevents unauthorized users from
   accessing the admin feature area.It redirects to the login page if the user is not authorized

- But the router is still loading the AdminModule even if the user cant visit any of its components.
- Ideally , youd load the AdminModule if the user is logged in .

- Add a CanLoad guard that only loads the AdminModule once the user is logged in and attempts to access the
  admin feature area

- The existing AuthGuard already has the essential logic in its checkLogin() method to support the CanLoad
  guard. 
- Open the auth.guard.ts. Import the CanLoad interface from '@angular/router'
- Add it to the AuthGuard class's implements list.
- Then implement canLoad() as follows
canLoad(route: Route): boolean {
  let url = `/${route.path}`;

  return this.checkLogin(url);
}

- The router sets the canLoad() method's route parameter to the intended destination URL.
- The checkLogin() method redirects to the URL once the user has logged in

- Now import the AuthGuard into the AppRoutingModule and add the AuthGuard to the canLoad array property for the
  admin route

Preloading: background loading for feature areas
------------------------------------------------

- You have learned how to load modules on-demand.
- You can also load modules asynchronously with preloading.

- This may seem like what the app has been doing all along. Not quite
- The AppModule is loaded when the application starts; thats eager loading.
- Now the AdminModule loads only when the use clicks on a link; that lazy loading

Preloading is something in between. Consider the Crisis Center.

- It isnt the first view that a user sees. By default, the Heroes are the first view
- For the smallest initial payload and fastest launch time, you should eagerly load the AppModule and
  the HeroesModule
- You could lazy load the CrisisCenter , but youre almost certain that the user will visit the CrisisCenter
  within minutes of launching app.
- Ideally the app would launch with just the AppModule and the HeroesModule loaded and then almost immediately
  , load the CrisisCenterModule in the background.
- By the time the user navigates to the CrisisCenter, its module will have been loaded and ready to go

How Preloading works

- After each successful navigation, the router looks inits configuration, for an unloaded module that it can
  preload
- Whether it preloads a module, and which modules it preloads, depends upon the preload strategy

The Router offers two preloading strategies out of the box:
   - No preloading at all which is the default. Lazy loaded feature areas are still loaded on demand
   - Preloading of all lazy loaded feature areas

Out of the box, the router either never preloads, or preloads every lazy load module
- The Router also supports 'custom preloading strategies' for fine control over which modules to preload and
  when


In this next section, you ill update the CrisisCenterModule to load lazily by default anduse the
preloadAllModules strategy to laod it( and all other lazy loaded modules) as soon as possible

Update the route configuration to lazy load the CrisisCenterModule. Take the same steps you used to configure AdminModule for lazy load.

Change the crisis-center path in the CrisisCenterRoutingModule to an empty string.

Add a crisis-center route to the AppRoutingModule.

Set the loadChildren string to load the CrisisCenterModule.

Remove all mention of the CrisisCenterModule from app.module.ts.


- To enable preloading of all lazy loaded modules, import the 'PreloadAllModules' token from the Angular
  router package.
- The second arguement in the RouterModule.forRoot() method takes an object for additional configuration
  options.
- The preloadingStrategy is one of those options.
- Add the PreloadAllModules token to the forRoot() call:
   preLoadStrategy: PreloadAllModules

- This tells the Router preloader to immediately load all lazy loaded routes(routes with a loadChildren property)
- When you visit http://localhost:4200, the /heroes route loads immediately upon launch and the router starts
  loading the CrisiCenterModule right after the HeroesModule loads

Surprising the AdminModule doesnot preload, something is blocking it


canLoad blocks preload
----------------------
- The PreLoadAllModules strategy doesnot load feature areas protected by a CanLoad guard. This is by design
- You added a CanLoad guard to the route in the AdminModule a few steps back to block loading of that module
  until the user is authorized. 
- CanLoad guard takes precedence over the preload strategy

- If you want to preload a module and guard against unauthorized access, drop the canLoad() guard method
  and rely on the canActivate() guard alone


Custom Preloading Strategy
--------------------------
- Preloading every lazy loaded modules works well in many situations , but it isnt always the right choice,
  especially on mobile devices and over low bandwidth connections.
- You may choose to preload only certain feature modules, based on user metrics and other business and technical
   factors

- You can control what and how the router preloads with a custom preloading strategy

In this section, you ill add a custom strategy that only preloads routes whose data.preload flag is set true.
Recall that you can add anything to the data property of route

- Set the data.preload flag in the crisis-center route in the AppRoutingModule

SelectivePreloadingStrategyService implements the PreloadingStrategy, which has one method, preload.

The router calls the preload method with two arguements:	
  1. The route to consider
  2. A loader function that can load the routed module asynchronously

- An implementation of preload must return an Observable. If the route should preload, it returns the observable
returned bu calling the loader function.

- If the route should not preload, it returns the Observable of null


Once the application loads the initial route, the CrisisCenterModule is preloaded. 
Verify this by logging int the Admin feature area and noting that the crisis-center is listed in the 
Preloaded Modules.


Migrating URLs with Redirects
_______________________________

- You've setup the routes for navigating around your application.
- You've used navigation imperatively and declaratively to many different routes.
- But like any application, requirements change over time. 
- You've set up links and navigation to /heroes and /hero/:id from the HeroListComponent and HeroDetailComponent.
- If there was a requirement that links to heroes become superheroes, you still want the previous URL's to
  navigate correctly. 
- You also dont want to go and update every link in your application, so redirect makes refactoring routes
  trivial

Changing /heroes to /superheroes
-------------------------------

- Let's take the Hero routes and migrate them to new URLs.
- The Router checks for redirects in your configuration before navigating , so each redirect is triggered
   when needed.
- To support this change, you ill add redirects from the old routes to the new routes in the
   heroes-routing.modules


- You ill notice two different types of redirects. The first change is from /heroes to /superheroes without
  any paramteres.
- This is straightforward redirect unlike the change from  /hero/:id to /superhero/:id which includes the
  :id route paramter
- Router redirects also use powerful pattern matching, so the Router inspects the URL and replaces route
  paramters in the path with their appropriate destination.
- Previously you navigated to a URL such as /hero/15 with a route paramter id of 15


The Router also supports query parameters and the fragment when using redirects
 - when using absolute redirects, the Router will use the query parameters and the fragment from the 
   redirectTo in the route config
 - when using relative redirects, the Router use the query params and the fragment from the source URL



- Currently our empty path route redirects to /heroes which redirects to /superheroes.(2 level redirection)
- This wont work and is by design, as the Router handles redirects once at each level of routing configuration
- This prevents chaining of redirects, which can lead to endless redirect loops

- Hence update the empty path route in app-routing.module.ts to redirect to /superheroes

- RouterLinks aren't tied to route configuration, so you ill need to update the associated router links so they
  remain active when the new route is active.

Update the goToHeroes() method in the hero-detail.component.ts to navigate back to /superheroes with optional
paramters

- With the redirects setup, all previous routes now point to their new destinations and both URL's still function
  as intended

Inspect the router's configuration
___________________________________

You put a lot of effort into configuring the router in several routing module files and were careful to list 
them in the proper order.
- Are roots actually evaluated as you planned ? How is the router really configured?

You can inspect the router's current configuration any time by injecting it and examining its config property
For example, update the AppModule as follows and look in the browser console window to see the finished route
configuration


Wrap up and final app
_____________________
 The balance of this guide is a set of appendices that elaborate some of the points you covered  quickly above

Appendix: link paramters array
------------------------------

- A link parameters array holds the following ingredients for router navigation:
  - the path of the route to the destination component
  - required and optional route paramters that go into the route url

You can bind the RouterLink directive to such an array like this
  <a [routerLink]="['/heroes']">Heroes</a>

You have written two elements array when specifying a route paramter like this
  <a [routerLink]="['/heroes', hero.id]">
    <span class="badge">{{hero.id}}</span>{{hero.name}}
  </a>

You can provide optional route paramters in an object like this
  <a [routerLink]="['/crisis-center', { foo: 'foo'}]">Crisis Center</a>


The above examples cover the need for an app with one level routing.
The moment you add a child router, such as crisis center, you create new link array possibilities


- Recall that you specified a default child route for this crisis center so this simple RouterLink is fine
<a [routerLink]="['/crisis-center']>Crisis Center</a>
Parse it out.

 - The first item in the array identifies the parent route (/crisis-center)
 - There are no paramters for this parent route so you are done with it
 - There is no default child route so you need to pick one
 - You are navigating to the CrisisListComponent, whose route path is /, but you dont need to explicitly add 
   the slash
 - voila ['/crisis-center']

Take it a step further. COnsider the following router link tht navigates from the root of the application
down to the Dragon Crisis

<a routerLink="['crisis-center', 1]">Dragon Crisis</a>

- Yhe first item in the array identifies the parent route (crisis-center)
- there are no parameters for this parent route so you are done with it
- the second item identifies the child route details about a particular crisis (/:id)
- the details child route requires an id route paramter
- you added the id of the dragon crisis as the second item in the array (1)
- the resulting path is /crisis-center/1


If you wanted to, you could redefine the AppComponent template with Crisis Center routes exclusively
template: `
  <h1 class="title">Angular Router</h1>
  <nav>
    <a [routerLink]="['/crisis-center']">Crisis Center</a>
    <a [routerLink]="['/crisis-center/1', { foo: 'foo' }]">Dragon Crisis</a>
    <a [routerLink]="['/crisis-center/2']">Shark Crisis</a>
  </nav>
  <router-outlet></router-outlet>
`

In sum up, you can write application with one, two are more levels of routing.
- The link parameters array affords the flixibility to represent any routing depth and any legal sequence
  of route paths, (required) router parameters and (optional) router parameter objects



Appendix: LocationStrategy and browser URL styles
___________________________________________________

- When the router navigates to a new component view, it updates the browsers location and history with a URL
for that view.
- This is a strictly local URL. The browser shouldnt send this URL to the server and should not reload the page


- Modern HTML5 browsers support history.pushState, a technique that changes a browser's location and history
without triggering a server page request.
- The route can compose a "natural" URL that is indistinguishable from one that would otherwise require a page
  load

Here is the Crisis Center URL in this HtmL5 pushState style
localhost:3002/crisis-center/


- Older browsers send page requests to the server when the location URL changes "Unless" the change occurs
  after a "#" (called the "hash").
- Routers can take advantage of this exception by composing 'in-application route URLs' with hashes
- Here's a "hash URL" that routes to the Crisis Center

localhost:3200/src/#/crisis-center/

The router supports both styles with two LocationStrategy providers:

1. PathLocationStrategy - the default "HTML5 pushState" style
2. HashLocationStrategy - the "hash URL" style


The RouterModule.forRoot() function sets the LocationStrategy to the 'PathLocationStrategy', making it
 the default strategy.
You can switch to HashLocationStrategy with an override during the bootstrapping process if you prefer


Which strategy is best ?
------------------------

- You must choose a strategy and you need to make the right call early in the project.
- It wont be easy to change later once the application is in production and there are lots of application URL
  references in the wild

- Almost all Angular projects should use the default HTML5 style. It produces URL's that are easier
 to understand. And it preserves the option to do server-side rendering later

  Rendering critical pages on the server is a technique that can greatly improve perceived responsiveness
  when the app first loads.
  An app that would otherwise take ten or more seconds to start could be rendered on the server and delivered
  to the users device in less than a second

- This option is only available if the application URL's look like normal web URL's without hashes(#) in the 
   middle.
- Stick with the default unless you have a compelling reason to resort to hash routes


The <base href>
_______________

- The router uses the browsers history.pushState for navigation.
- Thanks to pushState, you can make in-app URL paths look the way you want them to look.
  localhost:4200/crisis-center.
- The in-app urls can be indistinguishable from server URls

Modern HTML5 browsers were the first to support pushState which is why many ppl refer to these urls as
HTML5 style URLS

- You must add a <base href> element to the app's index.html for pushState routing to work
- The browser uses <base href> value to prefix relative URLs when referencing CSS files, scripts and images

- Add the <base> element just after the <head> tag. If the app folder is the application root, as it is for this
 applicaiotn, set the href value in the index.hml as shown here

<base href="/">

- Without that tag, the browser may not be able to load resources(images, CSS, scripts) when "deep linking"
  into the app.
- Bad things couldhappen when someone pastes an application link in the browsers address bar or clicks such
  a link in an email

SOme developers may not be able to add the <base> element, perhaps because they dont have access to <head>
or index.html file

Those developers may still use HTML5 URLs by taking two remedial stps
 - Provide router with an appropriate [APP_BASE_HREF][] value
 - Use root urls for all web resources : CSS, images, scripts and template HtmL files


HashLocationStrategy
___________________

You can go old school with the HashLocationStrategy by providing "useHash: true" in an object as the 
 second paramter of the RouterModule.forRoot() in the AppModule
RouterModule.forRoot(routes, { useHash: true })  // .../#/crisis-center/